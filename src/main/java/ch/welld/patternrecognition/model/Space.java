package ch.welld.patternrecognition.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

@Component
@SessionScope
@JsonSerialize
@JsonIgnoreProperties({"targetClass", "targetSource", "targetObject", "advisors", "advisorCount", "frozen", "exposeProxy", "preFiltered", "proxiedInterfaces", "proxyTargetClass"})
public class Space {
	
	private final Set<Point> points;
	
	public Space() {
		points = new TreeSet<>();
	}
	
	public void addPoint(Point point) {
		if (point == null) {
			throw new IllegalArgumentException("A point cannot be null");
		}
		boolean isAdded = points.add(point);
		if (!isAdded) {
			throw new IllegalArgumentException("The input point is already in the space");
		}
	}
	
	@JsonProperty(value = "points")
	public Collection<Point> getAllPoints() {
		return points;
	}
	
	// reference: https://coursera.cs.princeton.edu/algs4/assignments/collinear/specification.php
	@JsonIgnore
	public List<LineSegment> getAllLineSegments(int numPoints) {
		if (numPoints < 2 || points.size() < numPoints) {
			return new ArrayList<>(0);
		}
		List<LineSegment> result = new ArrayList<>();
		// 1) think of p as the origin
		for (Point p : points) {
			// 2) for each other point q, determine the slope it makes with p
			// (in order to compute the slope once, store it in an auxiliary map)
			Map<Point, Double> otherPointsWithSlopes = points.stream()
					.filter(q -> !q.equals(p))
					.collect(Collectors.toMap(Function.identity(), q -> q.slopeWith(p)));
			// 3) sort the points according to the slopes they make with p
			// (use the map values to compute a collection of map keys)
			List<Point> otherPointsSortedBySlopes = otherPointsWithSlopes.entrySet().stream()
					.sorted(Comparator.comparing(Map.Entry::getValue))
					.map(Map.Entry::getKey)
					.collect(Collectors.toList());
			// 4) check if any numPoints (or more) adjacent points in the sorted order have equal slopes with respect to p
			// (iterate over the sorted map keys and build the line segments by taking the group of adjacent points having the same slopes)
			double lastRetrievedSlope = Double.NaN;
			LineSegment currentLineSegment = null;
			for (Point q : otherPointsSortedBySlopes) {
				double retrievedSlope = otherPointsWithSlopes.get(q);
				if (Double.compare(retrievedSlope, lastRetrievedSlope) == 0 && currentLineSegment != null) {
					currentLineSegment.addPoint(q);
				} else {
					currentLineSegment = new LineSegment();
					currentLineSegment.addPoint(p);
					currentLineSegment.addPoint(q);
				}
				lastRetrievedSlope = retrievedSlope;
				// store the line segment if its size is equal to numPoints (this means that it is long enough to be in the output)
				if (currentLineSegment.getNumPoints() == numPoints) {
					result.add(currentLineSegment);
				}
			}
		}
		// remove the duplicate line segments (i.e., each segment generated by the points after the smallest one) before returning the collection
		return result.stream()
				.distinct()
				.collect(Collectors.toList());
	}
	
	@JsonIgnore
	public boolean isEmpty() {
		return points.isEmpty();
	}
	
	public void clear() {
		points.clear();
	}

	@Override
	public String toString() {
		return "Space [points=" + points + "]";
	}

}
